# macro

구현을 생각했을 때 매크로 파라미터에서 외부 변수의 캡쳐는 허용되지 않아야 할 것 같지만 다음과 같은 경우를 검사하고 싶어서 컴파일 타임 어썰션을 추가한다.

```zoa
let map = [
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 1, 1, 1],
    [0, 0, 0, 0, 0],
];

// assert length of all elements in map are equal
```

이건 [Jai 에서 정말 끝내주는 기능](https://youtu.be/UTqZNujQOlA?t=3226)이라고 생각하고 이게 어떻게 작동해야 할지 고민이 필요하다. TODO

만약 입력이 side effect 가 있는 입력이었다면 좀 고민해봐야하지만, 이런 경우에는 컴파일 타임에서 저 코드를 만나기까지 코드를 컴파일타임에서 실행해주는 것이 맞다고 생각한다.
가능하다면 실행에 필요한 최소한의 코드만을 실행하며, 그걸로 충분하지 않은 경우에는 컴파일 타임 어썰션을 제거하는 방식?

```zoa
struct Resources {
    pub sta map = [
        ...
    ]
}

let main = () {
    a();
    b();
}

let a = () {
    let new_data = [ ... ];
    Resources.map[0] = new_data;
}

let b = () {
    ascii_map(Resources.map); // <- ASSERT HERE
}
```

이런 코드가 있다면 컴파일러는 엔트리 포인트부터 map을 참조하는 코드들을 찾아 순서대로 그것만을 실행하고 (여기서는 `a() -> b()`) 그리고 `ascii_map` 내에 있는 assert 코드를 실행할 것이다.. 이게 말이야 방구야?? 그런데 Jai에서는 그렇게 한다고 한다. 그렇다면 나도 가능하겠지?

그렇다면 컴파일 타임에서 어썰트를 피하고 싶다면 다음처럼 할 수 있어야 하겠다

```zoa
ascii_map.unchecked(Resources.map);
```

아마 다음과 같은 경우는 컴파일 타임 어썰션보다는 런타임 어썰션이 더 어울리는 상황이다.

```zoa
let map = std.io.file.open("data.txt").read_all_lines();
ascii_map(map);
```

이렇게 된다면 굳이 컴파일 타임 어썰션을 넣었을 때 오히려 쓸데없는 코드가 늘어날 수 있어서 그렇게 좋은 상황은 아니라고 본다.
~~지금의 문제는 컴파일 타임 어썰션이 있는 코드를 사용하다, 그 코드를 확장했을 때 런타임에서 값이 바뀌는 변수가 파라미터로 넘겨졌을 때 컴파일 타임 어썰션 코드를 주석처리해야 한다는 번거로움이 있다.. 이런 경우에 한해서이지만.~~ -> `unchecked` 와 같은 메서드의 멤버 변수를 사용해 어썰션을 제외한 메서드를 사용하면 된다. 물론 다른 방법이 있을 수도 잇다..

하지만 앞서 말한 아스키 맵 컴파일타임 어썰션은 봤을때 정말 쿨해보인다

## Type instead of compile time assertion

생각해보니 이전에 계속 생각했었던 타입을 사용한 에러 없는 코딩이 컴파일 타임 어썰션을 충분히 대체할 수 있을 것으로 보인다.

```zoa
type AllElementsLengthEqual = ...

let ascii_map = (map: [[int]] | AllElementsLengthEqual) {
    ...
}
```

혹은 다음과 같은 코드를 생각했었다.

```zoa
struct Array {
    let length: int;

    ...
    let [] = (index: int | LessThan<length>) {
        ...
    }
}
```

이렇게 타입을 사용해 값을 검증함으로써 값이 안전함을 강제할 수 있으며 그렇지 않은 경우에는 파라미터를 넘기기 전에 fail 하거나 다른 루틴을 가는 방식이 되어야 하는 식으로 역시 값은 언제나 안전함을 보일 수 있다.
프로그램 (메서드)의 실행 결과의 유효성을 Optional로 본다면 파라미터의 유효성은 이 타입 어썰션을 사용해 볼 수 있다고 할 수 있다. 양쪽 다 명시적이며 프로그래머에게 상기시킬 수 있다.

컴파일 타임 어썰션이 들어간 코드에서 어썰션을 빼는 것은 암묵적이며 마치 try~catch 구문과 비슷한 맥락이다. 그리고 타입을 이용한 값 검증은 명시적인 Optional 과 비슷하다.

그치만.. 역시 이렇게 코드를 작성하면 안전한 코드를 작성할 수 있겠지만 Optional과 비교가 안되게 코드가 길어지고 각 케이스마다 타입을 만들고/알아야 하기 때문에 코드를 작성하는데 비용이 더 많이 들 것이다.. 배보다 배꼽이 더 크게 됨

## Condition attribute

어트리뷰트를 사용한다.

```zoa
let same_length = (item: [[int]]) -> bool {
    ...
}

let ascii_map = ([Cond(same_length)] map: [[int]]) {
    ...
};
```

어트리뷰트에 대해서 생각해보지는 않았지만 그래도 이런 것도 되겠다 라고 생각한다

## When we need compile time assertion and why

컴파일 타임 어썰션은 테스트 코드를 작성하는게 아닌 개발자의 실수를 방지하기 위함이다. 크기가 10인 배열에서 반복문에서 인덱스의 최대값을 11로 잡았다거나, 아까와 같은 크기가 다른 배열이 있는 맵 데이터를 넘겨주는 등을 컴파일러가 알아서 방지해주는 용도이다. 이런 시나리오들을 생각해보자..

 - 배열의 인덱스를 상수로 넣었을 때 오버플로우
 - 반복문에서 최대값까지 증가하는 변수를 배열의 인덱스로 넣었을 때 오버플로우
 - 인스턴스에서 필요한 초기화 메서드를 실행하지 않고 사용한 경우
 - 