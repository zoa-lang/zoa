# macro

구현을 생각했을 때 매크로 파라미터에서 외부 변수의 캡쳐는 허용되지 않아야 할 것 같지만 다음과 같은 경우를 검사하고 싶어서 컴파일 타임 어썰션을 추가한다.

```zoa
let map = [
    [0, 0, 0, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 1, 1, 1],
    [0, 0, 0, 0, 0],
];

// assert length of all elements in map are equal
```

이건 [Jai 에서 정말 끝내주는 기능](https://youtu.be/UTqZNujQOlA?t=3226)이라고 생각하고 이게 어떻게 작동해야 할지 고민이 필요하다. TODO

만약 입력이 side effect 가 있는 입력이었다면 좀 고민해봐야하지만, 이런 경우에는 컴파일 타임에서 저 코드를 만나기까지 코드를 컴파일타임에서 실행해주는 것이 맞다고 생각한다.
가능하다면 실행에 필요한 최소한의 코드만을 실행하며, 그걸로 충분하지 않은 경우에는 컴파일 타임 어썰션을 제거하는 방식?

```zoa
struct Resources {
    pub sta map = [
        ...
    ]
}

let main = () {
    a();
    b();
}

let a = () {
    let new_data = [ ... ];
    Resources.map[0] = new_data;
}

let b = () {
    ascii_map(Resources.map); // <- ASSERT HERE
}
```

이런 코드가 있다면 컴파일러는 엔트리 포인트부터 map을 참조하는 코드들을 찾아 순서대로 그것만을 실행하고 (여기서는 `a() -> b()`) 그리고 `ascii_map` 내에 있는 assert 코드를 실행할 것이다.. 이게 말이야 방구야?? 그런데 Jai에서는 그렇게 한다고 한다. 그렇다면 나도 가능하겠지?

그렇다면 컴파일 타임에서 어썰트를 피하고 싶다면 다음처럼 할 수 있어야 하겠다

```zoa
ascii_map.unchecked(Resources.map);
```

아마 다음과 같은 경우는 컴파일 타임 어썰션보다는 런타임 어썰션이 더 어울리는 상황이다.

```zoa
let map = std.io.file.open("data.txt").read_all_lines();
ascii_map(map);
```

이렇게 된다면 굳이 컴파일 타임 어썰션을 넣었을 때 오히려 쓸데없는 코드가 늘어날 수 있어서 그렇게 좋은 상황은 아니라고 본다.
~~지금의 문제는 컴파일 타임 어썰션이 있는 코드를 사용하다, 그 코드를 확장했을 때 런타임에서 값이 바뀌는 변수가 파라미터로 넘겨졌을 때 컴파일 타임 어썰션 코드를 주석처리해야 한다는 번거로움이 있다.. 이런 경우에 한해서이지만.~~ -> `unchecked` 와 같은 메서드의 멤버 변수를 사용해 어썰션을 제외한 메서드를 사용하면 된다. 물론 다른 방법이 있을 수도 잇다..

하지만 앞서 말한 아스키 맵 컴파일타임 어썰션은 봤을때 정말 쿨해보인다